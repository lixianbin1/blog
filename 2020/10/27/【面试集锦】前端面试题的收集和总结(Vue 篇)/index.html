<!DOCTYPE html>
<html>
  
<head>
  <meta charset="utf-8">
  <meta name="author" content="饿包子" />
  
  
  <title>前端面试题的收集和总结(Vue 篇) | 饿包子博客</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="面试合集," />
  

  
  <meta name="description" content="Vue的篇章">

  
  
    <link rel="icon" href="/blog/images/xian.ico">
    <link rel="apple-touch-icon" href="/blog/images/Logo.png">
  

  
<link rel="stylesheet" href="/blog/css/Awesome.min.css">


  <!-- 引入主CSS -->
  
<link rel="stylesheet" href="/blog/css/index.css">


  <!-- 引入自定义highlightCSS -->
  
<link rel="stylesheet" href="/blog/styles/highlight/a11y-dark.min.css">
<link rel="stylesheet" href="/blog/styles/highlight/index.css">

  <!-- 
<script src="/blog/styles/highlight/javascript.min.js"></script>
 -->

  
  
<script src="/blog/common/jquery.min.js"></script>


  
    
<script src="/blog/common/MathJax.js"></script>

  

  

  <script>
  // theme-ad's config script
  // it can be used in every script
  
  window.AD_CONFIG = {
    welcome: {"enable":false,"interval":30},
    start_time: "2018-06-10",
    passwords: ["a621ab606db2a11f63edc576a729843b8269250dc324206871d90635ac5e531c", ],
    is_post: true,
    lock: false,
    author: "饿包子",
    share: {"twitter":false,"facebook":false,"weibo":true,"qq":true,"wechat":false},
    mathjax: true,
    page_type: "",
    root: "/blog/"
  };
</script>

  
<script src="/blog/vendor/sha256.min.js"></script>
<script src="/blog/js/auth.js"></script>
<script src="/blog/js/index.js"></script>
<script src="/blog/vendor/qrcode.min.js"></script>


<meta name="generator" content="Hexo 5.4.2"></head>
  <body>
    <header class="site-header">
  <div class="site-header-brand">
    
      <span class="site-header-brand-title">
        <a href="/blog/">清风逐月</a>
      </span>
    
    
      <span class="site-header-brand-motto"> | 我思故我在</span>
    
  </div>
  <div class="site-header-right">
    <nav class="site-header-navigation">
      
        <a href="/blog/" target="_self">主页</a>
      
        <a href="/blog/archives/" target="_self">归档</a>
      
        <a href="/blog/tags/" target="_self">标签</a>
      
        <a href="/blog/categories/" target="_self">分类</a>
      
        <a href="/blog/about/" target="_self">关于</a>
      
    </nav>
    <div class="site-header-btn">
      
        <a href="https://github.com/lixianbin1/" target="_blank" id="site-github">
          <i class="fa fa-github-alt"></i>
        </a>
      
      <a href="javascript:void(0);" id="site-search">
        <i class="fa fa-search"></i>
      </a>
      <a href="javascript:void(0);" id="site-nav-btn">
        <i class="fa fa-ellipsis-v"></i>
      </a>
    </div>
  </div>
</header>
<nav class="table-content" id="site-nav">
  <div class="table-content-title">
    <span>导航</span>
  </div>
  <div class="table-content-main">
    <ol class="toc">
      
        <li class="toc-item">
          <a href="/blog/" target="_self">
            主页
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/blog/archives/" target="_self">
            归档
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/blog/tags/" target="_self">
            标签
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/blog/categories/" target="_self">
            分类
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/blog/about/" target="_self">
            关于
          </a>
        </li>
      
    </ol>
  </div>
</nav>
<div id="site-process"></div>
    <main>
      
  <!-- passage -->
<div class="passage">
  <div class="passage-meta">
    <span>
      <i class="fa fa-calendar"></i>2020-10-27
    </span>
    
      <span>
        | <a href="/blog/categories/%E9%9D%A2%E8%AF%95%E5%90%88%E9%9B%86/"><i class="fa fa-bookmark"></i>面试合集</a>
      </span>
    
    
      <span>
        | <i class="fa fa-unlock-alt"></i>UNLOCK
      </span>
    
    <span>
       | <i class="fa fa-calendar"></i>更新时间:2022-9-5 16:52 
    </span>
  </div>
  <h1 class="passage-title">
    前端面试题的收集和总结(Vue 篇)
  </h1>
  
  <article class="passage-article">
    <h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="Vue-和-React-的区别？"><a href="#Vue-和-React-的区别？" class="headerlink" title="Vue 和 React 的区别？"></a>Vue 和 React 的区别？</h3><ul>
<li><code>react</code> 整体是函数式的思想，把组件设计成纯函数，状态和逻辑通过参数传入，所以在 <code>react</code> 中，是单向数据流，而vue的思想是响应式的，也就是基于是数据可变的，数据双向绑定，通过对每一个属性建立 <code>Watcher</code> 来监听，当属性变化的时候，响应式的更新对应的虚拟dom；</li>
<li><code>react</code> 通过js来操控一切，设计了 <code>jsx</code>，通过 <code>jsx</code> 来生成 <code>html</code> ，<code>css</code> 。 <code>vue</code> 则把 <code>html</code> ，<code>css</code> ，<code>js</code> 组合到一起，用各自的处理方式，<code>vue</code> 有单文件组件，可以把 <code>html</code> 、 <code>css</code> 、 <code>js</code> 写到一个文件中，<code>html</code> 提供了模板引擎来处理</li>
<li><code>react</code> 更喜欢规范化用户，搭建一个规范化的架构，然后让用户，社区去做更多，而 <code>vue</code> 则内置了更多API,更为用户考虑更多，<code>vue</code> 提倡开发更简便。</li>
</ul>
<h3 id="说说你对virtual-Dom-虚拟dom-的理解？"><a href="#说说你对virtual-Dom-虚拟dom-的理解？" class="headerlink" title="说说你对virtual Dom(虚拟dom)的理解？"></a>说说你对virtual Dom(虚拟dom)的理解？</h3><p>虚拟 dom 是对真实 dom 的抽象，本质上是 <code>JavaScript对象</code> ，通过 <code>JavaScript对象</code>去描述真实DOM，在状态改变时，通过对新旧虚拟 dom 树的差异，在真实 dom 进行局部改变，尽可能的减少对真实 dom 的操作和重绘。它的优点在于保证了性能的下限，同时不需手动操作真实dom，缺点在于无法做到性能的极致优化，同时因为多了一层计算，有时会比直接操作真实dom要慢。</p>
<h3 id="说是你对Vue数据单向流的理解？"><a href="#说是你对Vue数据单向流的理解？" class="headerlink" title="说是你对Vue数据单向流的理解？"></a>说是你对Vue数据单向流的理解？</h3><p>数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父组件的状态，从而导致你的应用的数据流向难以理解</p>
<h3 id="为什么组件的-data-是一个函数？"><a href="#为什么组件的-data-是一个函数？" class="headerlink" title="为什么组件的 data 是一个函数？"></a>为什么组件的 data 是一个函数？</h3><p>因为组件是用来复用的，为了防止<code>data</code>复用，将其定义为函数.数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的 data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，因为这些实例共用同一个构造函数，就使得所有组件实例共用了一份data，会造成一个组件变化导致全部组件都会变的结果。</p>
<h3 id="vue-怎么让-CSS-只在当前组件生效？"><a href="#vue-怎么让-CSS-只在当前组件生效？" class="headerlink" title="vue 怎么让 CSS 只在当前组件生效？"></a>vue 怎么让 CSS 只在当前组件生效？</h3><p>可以在当前组件的style 上添加 scoped； 如果需要影响第三方组件，可以通过在入口文件中配置相关CSS进行样式重写，或者通过 <code>/deep/</code> 声明进行样式穿透。</p>
<h3 id="Vue中的通信方式有哪些？简介介绍一下。"><a href="#Vue中的通信方式有哪些？简介介绍一下。" class="headerlink" title="Vue中的通信方式有哪些？简介介绍一下。"></a>Vue中的通信方式有哪些？简介介绍一下。</h3><ul>
<li><code>props</code> 和 <code>$emit</code> : 父组件通过<code>props</code>向子组件传递数据，子组件通过<code>$emit</code>方法向父组件传递数据</li>
<li><code>$parent</code> , <code>$children</code> 和 <code>$refs</code> : <code>$parent</code> 和 <code>$children</code> 分别指向父组件和子组件实例，<code>$refs</code>则指向所设置的ref组件实例，可以通过实例直接获取它们的data和方法</li>
<li><code>Vuex</code> : 可以通过Vuex状态管理，各组件通过<code>action</code>，<code>mutation</code> 和 <code>state</code>进行数据的存取，说偏一点，也可以通过 <code>localStorage</code> 和 <code>sessionStorage</code> 进行数据传递</li>
<li><code>$attrs</code> 和 <code>$listeners</code> : <code>$attrs</code> 会获取父组件通过props传递过来但没被自己使用的值，<code>$listeners</code> 会获取父组件通过<code>v-on</code> 绑定的事件</li>
<li><code>envetBus</code> : 事件总线，通过在main中设置 <code>Vue.prototype.$eventBus = new Vue()</code> ,然后在需要的地方通过对 this.$eventBus 设置 <code>$emit</code> <code>$on</code> 进行事件触发和监听</li>
</ul>
<h3 id="vue的指令有哪些？讲几个你比较常用的"><a href="#vue的指令有哪些？讲几个你比较常用的" class="headerlink" title="vue的指令有哪些？讲几个你比较常用的"></a>vue的指令有哪些？讲几个你比较常用的</h3><pre><code class="hljs md">vue的指令有
v-on:绑定事件      v-bind:绑定属性    v-model:双向绑定   v-once单次渲染 ; 
v-if=&quot;条件判断&quot;    v-else-if=&quot;条件&quot;   v-else            v-for=&quot;i in 循环渲染&quot;;
v-text=&quot;绑定文本&quot;  v-pre=&quot;pre文本&quot;    v-html=&quot;innerHtml文本&quot;; 
v-slot:具名插槽使用,只能在template上   v-cloak 可以和CCS规则[v-clock]结合使用</code></pre>

<h3 id="说说你对-v-modal-的理解？"><a href="#说说你对-v-modal-的理解？" class="headerlink" title="说说你对 v-modal 的理解？"></a>说说你对 v-modal 的理解？</h3><p><code>v-modal</code> 在官方文档中的解释是，它是一种语法糖，会自动的在元素或者组件上面解析为 <code>value</code> 属性 和 <code>input</code> 事件. 它的核心实质是通过 object.defineProperty 劫持各个属性，当监听到变化后通过相应的页面元素更新，另一方面通过通过编译模板文件，为控件的v-model绑定input事件，从而页面输入能实时更新相关data属性值</p>
<h3 id="vue修饰符你用过哪些，讲一讲"><a href="#vue修饰符你用过哪些，讲一讲" class="headerlink" title="vue修饰符你用过哪些，讲一讲"></a>vue修饰符你用过哪些，讲一讲</h3><p>vue修饰符的话分 事件修饰符，按键修饰符，鼠标修饰符和表单修饰符。<br><strong>事件修饰符</strong>的话有：.stop(阻止冒泡事件) .prevent(阻止默认事件) .capture(点击子元素，在冒泡前触发) .self(只接受当前元素，不接受冒泡) .native(监听组件根元素的事件) .once(只执行一次) .passive(滚动事情会不停触发，不会阻止默认事件)<br><strong>按键修饰符</strong>的话有：.enter .tab .esc .space  .up .down .ctrl .alt .shift .meta(系统按键) .exact 等等，<br><strong>鼠标修饰符</strong>的话有：.left .right .middle<br><strong>表单修饰符</strong>的话有：.lazy(只有失去焦点，触发change事件后才会触发） .trim(清除输入框里的前后空白字符串<br>.number(对数据进行parseFloat,既前面字符串为数字则解释为数字，否则不解析)</p>
<h3 id="单向数据绑定和双向数据绑定的区别？"><a href="#单向数据绑定和双向数据绑定的区别？" class="headerlink" title="单向数据绑定和双向数据绑定的区别？"></a>单向数据绑定和双向数据绑定的区别？</h3><p>单向数据绑定就是简单的将modal数据绑定在view视图上，当数据改变的时候，view视图也跟着改变，但用户输入的时候，modal中的数据却不会跟着改变。而双向数据绑定则会跟着用户的输入，改变modal中的数据</p>
<h3 id="VUE数据双向绑定的原理？"><a href="#VUE数据双向绑定的原理？" class="headerlink" title="VUE数据双向绑定的原理？"></a>VUE数据双向绑定的原理？</h3><p><code>Vue</code> 采用数据劫持加发布者-订阅者模式的方式，遍历 <code>data</code> 中的所有属性，通过 <code>Object.defineProperty()</code> 来劫持各个属性的 <code>setter</code> 、<code>getter</code> ，在数据变动时通过<code>Dep算法</code> 遍历所有订阅者，发布消息给订阅者，触发相应的监听回调，完成订阅视图的改变</p>
<h3 id="Vue事件绑定的原理，讲一下？"><a href="#Vue事件绑定的原理，讲一下？" class="headerlink" title="Vue事件绑定的原理，讲一下？"></a>Vue事件绑定的原理，讲一下？</h3><p>Vue中通过v-on或其语法糖@指令来给元素绑定事件，基本流程是进行模板编译生成AST，生成render函数后并执行得到VNode，VNode生成真实DOM节点或者组件时候使用addEventListener方法进行事件绑定</p>
<h3 id="Vue可以数据劫持知道数据变化，为什么还要虚拟dom进行diff检测？"><a href="#Vue可以数据劫持知道数据变化，为什么还要虚拟dom进行diff检测？" class="headerlink" title="Vue可以数据劫持知道数据变化，为什么还要虚拟dom进行diff检测？"></a>Vue可以数据劫持知道数据变化，为什么还要虚拟dom进行diff检测？</h3><p>vue是通过watcher知道数据发生了变化，每绑定一个数据，就会产生一个watcher，一旦绑定颗粒度过细就会产生大量的watcher，这对内存和依赖开销打来很大的负担，所以vue在组件级进行push检测，当检测到组件发生改变，通过diff算法，获取组件的差异变化，然后进行视图的改变</p>
<h3 id="VUE的网络请求放哪？"><a href="#VUE的网络请求放哪？" class="headerlink" title="VUE的网络请求放哪？"></a>VUE的网络请求放哪？</h3><blockquote>
<p>一般看网络请求的涉及情况，如果网络请求涉及到dom节点加载后处理，那就放在 mounted 生命周期，如果未涉及到，则可以放在 created 周期，至于为什么不放 beforeCreate 和  beforeMounte，则是因为beforecreate 部署了方法运算和watch监测，beforeMounte 则比created 晚</p>
</blockquote>
<h3 id="VUE的生命周期有哪些？"><a href="#VUE的生命周期有哪些？" class="headerlink" title="VUE的生命周期有哪些？"></a>VUE的生命周期有哪些？</h3><pre><code class="hljs scss">vue的生命周期有：
beforeCreate (在实例初始化之后,进行数据侦听和事件/侦听器的配置之前同步调用)
created      (在实例创建完成后被立即同步调用，数据侦听和事件已经配置完成)
beforeMount  (挂载开始之前，相关的 `render` 函数被首次调用)
mounted      (实例挂载后调用)
beforeUpdate (数据更新时调用，虚拟DOM渲染之前，状态更改但未被渲染)
updated      (数据导致虚拟daom重新渲染后调用) 
<span class="hljs-built_in">beforeDestroy</span>(实例销毁之前，实例任然可用)
destroyed    (实例销毁后，子实例也被销毁)

activated    (在缓存组件 keep-alive 激活时触发)
deactivated  (在缓存组件 keep-alive 停用时触发) 
<span class="hljs-built_in">errorCaptured</span>(捕获到子组件错误的时候触发)</code></pre>
<p>扩展：updated 生命周期不保证子组件的重新绘制，可以在updated里调用$nextTick() 保证视图已全重新渲染。</p>
<h3 id="Vue的生命钩子如何实现？"><a href="#Vue的生命钩子如何实现？" class="headerlink" title="Vue的生命钩子如何实现？"></a>Vue的生命钩子如何实现？</h3><p>Vue 的生命周期钩子核心实现是利用发布订阅模式先把用户传入的生命周期钩子订阅好（内部采用数组的方法存储）然后在创建组件实例的过程中会一次执行对应的钩子方法（发布）</p>
<h3 id="函数式组件和普通组件的区别？"><a href="#函数式组件和普通组件的区别？" class="headerlink" title="函数式组件和普通组件的区别？"></a>函数式组件和普通组件的区别？</h3><p>不需要实例化，没有生命周期钩子函数，不能使用计算属性，watch；没有普通组件里的this调用；props不需要显示声明，结构简单，代码清晰。</p>
<h3 id="Vue中-key的作用和原理？"><a href="#Vue中-key的作用和原理？" class="headerlink" title="Vue中 key的作用和原理？"></a>Vue中 key的作用和原理？</h3><p><strong>为了更高效的更新虚拟dom</strong> key 主要用在 Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。作用是为了更快速定位出相同的新旧节点，尽量减少 DOM 的创建和销毁的操作,基于key的变化重新排列元素顺序，并且会移除key不存在的元素; 如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试再利用相同类型元素的算法。<br>有相同父元素的子元素必须有独特的key。重复的key会造成渲染错误</p>
<h3 id="watch、methods-和-computed-的区别"><a href="#watch、methods-和-computed-的区别" class="headerlink" title="watch、methods 和 computed 的区别?"></a>watch、methods 和 computed 的区别?</h3><p>watch 是用于监听某些数据的回调。每当所监听的数据发生变化时才能执行回调处理,适用于复杂的业务逻辑<br>methods 一般是用于书写业务逻辑的方法，methods会将这些方法混入vue实例中，然后这些方法可以通过vm实例进行访问<br>computed 是计算属性，在监听到依赖值的变化后，通过计算从而动态返回内容，主要目的是简化模板内的复杂运算，它会被缓存，只有依赖发生变化的时候，它才会执行运算</p>
<h3 id="v-show和v-if指令的共同点和不同点"><a href="#v-show和v-if指令的共同点和不同点" class="headerlink" title="v-show和v-if指令的共同点和不同点?"></a>v-show和v-if指令的共同点和不同点?</h3><p>共同点在于都能控制元素的显示和隐藏；不同点在于实现本质方法不同，v-show本质就是通过控制css中的display设置为none，控制隐藏，只会编译一次；v-if是动态的向DOM树内添加或者删除DOM元素，若初始值为false，就不会编译了。而且v-if不停的销毁和创建比较消耗性能。所以v-if比较适合不会频繁切换状态的元素，可以有效降低首次加载的编译时间，v-show则适合频繁切换状态的元素，可以防止频繁切换导致编译问题；</p>
<h3 id="为什么Vue中的v-if-和v-for不建议一起用？"><a href="#为什么Vue中的v-if-和v-for不建议一起用？" class="headerlink" title="为什么Vue中的v-if 和v-for不建议一起用？"></a>为什么Vue中的v-if 和v-for不建议一起用？</h3><p>在Vue早期版本中可以一起使用，现在已经不能一起使用了,必须分开使用。早期版本中当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。这意味着 v-if 将分别重复运行于 每个 v-for 循环中，即先运行 v-for 的循环，然后在每一个 v-for 的循环中，再进行 v-if 的条件对比，会造成性能问题，影响速度。</p>
<h3 id="delete和vue-delete的区别？"><a href="#delete和vue-delete的区别？" class="headerlink" title="delete和vue.delete的区别？"></a>delete和vue.delete的区别？</h3><p>delete仅仅只会删除值，内存占位还在。而vue.delete会删除其在内存中的占位，例如数组，delete仅删除改位置上的值，数组长度不变，而vue.delete则会删除其的占位，数组长度变短</p>
<h3 id="Vue的有用的属性和方法？"><a href="#Vue的有用的属性和方法？" class="headerlink" title="Vue的有用的属性和方法？"></a>Vue的有用的属性和方法？</h3><ul>
<li>Vue.nextTick(()=&gt;{ }) 会等下次dom渲染后执行函数；可以用于created生命周期执行副作用操作</li>
<li>keep-alive 缓存组件；在包裹其他组件的时候；会缓存不活动的组件，而不是销毁它，但还是会删除dom</li>
</ul>
<h3 id="说说-vue-router"><a href="#说说-vue-router" class="headerlink" title="说说 vue-router"></a>说说 vue-router</h3><p>vue-router通过hash 与History interface两种方式实现前端路由，更新视图但不重新请求页面”是前端路由原理的核心之一；hash模式，在url后面会添加 # ,路由会添加在 # 后面。通过监听hashChange事件来重新渲染页面但不刷新，而 history 模式在url的表现上则和正常路由基本一致，通过调用 history.pushState方法并监听popstate事件来实现，但在刷新的时候会因为没有这个路径的文件导致404。需要在Nginx配置将页面执向项目的index文件。</p>
<h3 id="route-和-router-的区别是什么？"><a href="#route-和-router-的区别是什么？" class="headerlink" title="route 和 router 的区别是什么？"></a>route 和 router 的区别是什么？</h3><p>route是“路由信息对象”，包括path,params,hash,query,fullPath,matched,name等路由信息参数<br>router是“路由实例对象”，包括了路由的跳转方法(push、replace)，钩子函数等。</p>
<h3 id="说一下你用过的的路由函数钩子-路由导航守卫-？"><a href="#说一下你用过的的路由函数钩子-路由导航守卫-？" class="headerlink" title="说一下你用过的的路由函数钩子(路由导航守卫)？"></a>说一下你用过的的路由函数钩子(路由导航守卫)？</h3><p>vue-router 的话有 </p>
<ul>
<li>全局守卫</li>
</ul>
<p><strong>beforeEach</strong> (全局前置守卫)，它是路由转跳之前触发的，一般用于路由权限检测，判断登录转跳等，<br><strong>beforeResolve</strong> (全局解析守卫)和前置守卫类似，可以用于注册全局守卫，但它是在导航确认之前，组件和异步解析之后。<br><strong>afterEach</strong> (全局后置钩子)和守卫不同，钩子不接受next函数，也不改变导航本身，一般用来处理转跳执行的操作，但是不改变导航的操作</p>
<ul>
<li>独享守卫</li>
</ul>
<p><strong>beforeEnter</strong> (路由独享守卫)：在路由配置中单独给某个路由配置的，用法和beforeEchart 一样</p>
<ul>
<li>组件守卫</li>
</ul>
<p>**beforeRouteEnter **：在组件实例创建之前执行的钩子，它不能访问this<br>**beforeRouteUpdate **：在路由改变且组件更新的时候进行访问<br><strong>beforeRouterLeave</strong>:在路由离开组件时调用</p>
<h3 id="有使用过Vue的动态路由，讲一下"><a href="#有使用过Vue的动态路由，讲一下" class="headerlink" title="有使用过Vue的动态路由，讲一下"></a>有使用过Vue的动态路由，讲一下</h3><p>很多时候，我们有list的详情页需要查询，因为文件名或者用户是不确定，有时候需要动态在路由里配置文件名或者其他动态ID之类的路由。这时候一般直接在Vue-router中配置就好了，以冒号配置需要动态变化的路径</p>
<h3 id="讲一下你对VUEX的理解"><a href="#讲一下你对VUEX的理解" class="headerlink" title="讲一下你对VUEX的理解?"></a>讲一下你对VUEX的理解?</h3><p>vuex是专门给vue开发出来的一个状态管理模式；</p>
<ul>
<li>采用集中式存储管理应用的所有组件的状态；Vuex 通过单一状态树管理所有数据，通过<code>store.state </code>来访问组件状态；</li>
<li>Vuex通过Getter 来派生一些状态，类似计算属性，可以通过<code>store.getter </code>来访问派生属性；</li>
<li>更改Vuex中状态的唯一办法就是commit Mutation；必须是同步函数；<code>mutation</code>可以通过判断传入的type，完成不同的对state的修改</li>
<li>Vuex通过<code>action </code>来commit mutation来修改 state，action可以用来作异步处理,可以通过store.dispatch action访问执行</li>
<li>vuex 通过<code>modules</code>对 store 进行拆分，每个module都有自己的action，mmutation 等，再通过modules合并到同一个store</li>
</ul>
<h3 id="如果把数据请求放在vuex中，你放在那里？"><a href="#如果把数据请求放在vuex中，你放在那里？" class="headerlink" title="如果把数据请求放在vuex中，你放在那里？"></a>如果把数据请求放在vuex中，你放在那里？</h3><blockquote>
<p>可以把数据请求放在放在action里面，结合ES6的 Promise()异步返回数据，然后通过dispatch这个action来访问请求，再通过then()方法对返回的数据进行处理。</p>
</blockquote>
<pre><code class="hljs coffeescript">actions:&#123;
  getName(&#123;commit&#125;)&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> promise(<span class="hljs-function"><span class="hljs-params">(res,rej)</span>=&gt;</span>&#123;
      axios().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;
        res(<span class="hljs-string">&#x27;ok&#x27;</span>)   <span class="hljs-regexp">//</span>返回异步成功
      &#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;
        rej(<span class="hljs-string">&#x27;no&#x27;</span>)   <span class="hljs-regexp">//</span>返回异步失败
      &#125;)
      commit(<span class="hljs-string">&#x27;get&#x27;</span>) <span class="hljs-regexp">//</span>通过commit触发mutation，间接改变state
    &#125;)
  &#125;
&#125;</code></pre>

<h3 id="Vuex的属性有哪些？"><a href="#Vuex的属性有哪些？" class="headerlink" title="Vuex的属性有哪些？"></a>Vuex的属性有哪些？</h3><p>Vuex的属性有 <code>state</code> <code>getter</code> <code>mutation</code> <code>action</code> <code>modules</code>, state用于存储vue的基本数据；getter用于派生一些状态类似计算属性。mutation用于提交数据的方法，是同步；action也用于提交数据，不过是触发的是mutation，modules模块化vue，让每个模块都有自己的属性。</p>
<h3 id="如果要优化一个Vue项目，怎么做？"><a href="#如果要优化一个Vue项目，怎么做？" class="headerlink" title="如果要优化一个Vue项目，怎么做？"></a>如果要优化一个Vue项目，怎么做？</h3><p>图片的优化，大型图片的懒加载和缩略显示，以及一些小图的雪碧图合并。请求链接的合并，减少请求链接数，降低对象层级，对象层级太深会导致性能变差。异步组件的的加载，路由的懒加载和第三方组件的按需加载。防抖和节流的应用等等</p>
<h3 id="讲一下Vue的自定义指令，你怎么写的？"><a href="#讲一下Vue的自定义指令，你怎么写的？" class="headerlink" title="讲一下Vue的自定义指令，你怎么写的？"></a>讲一下Vue的自定义指令，你怎么写的？</h3><p>除了默认的指令，Vue允许我们注册自定义指令，我们可以通过Vue.directives全局自定义指令，也可以通过directives选项注册局部自定义指令。同时Vue会提供几个钩子函数以供你使用编辑。像 bind inserted update componentUpdated unbind。</p>
  </article>
  <aside class="table-content" id="site-toc">
  <div class="table-content-title">
    <i class="fa fa-arrow-right fa-lg" id="site-toc-hide-btn"></i>
    <span>目录</span>
  </div>
  <div class="table-content-main">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue"><span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E5%92%8C-React-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Vue 和 React 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9virtual-Dom-%E8%99%9A%E6%8B%9Fdom-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">说说你对virtual Dom(虚拟dom)的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E6%98%AF%E4%BD%A0%E5%AF%B9Vue%E6%95%B0%E6%8D%AE%E5%8D%95%E5%90%91%E6%B5%81%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">说是你对Vue数据单向流的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BB%84%E4%BB%B6%E7%9A%84-data-%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">为什么组件的 data 是一个函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E6%80%8E%E4%B9%88%E8%AE%A9-CSS-%E5%8F%AA%E5%9C%A8%E5%BD%93%E5%89%8D%E7%BB%84%E4%BB%B6%E7%94%9F%E6%95%88%EF%BC%9F"><span class="toc-text">vue 怎么让 CSS 只在当前组件生效？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E4%B8%AD%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E7%AE%80%E4%BB%8B%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E3%80%82"><span class="toc-text">Vue中的通信方式有哪些？简介介绍一下。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E7%9A%84%E6%8C%87%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E8%AE%B2%E5%87%A0%E4%B8%AA%E4%BD%A0%E6%AF%94%E8%BE%83%E5%B8%B8%E7%94%A8%E7%9A%84"><span class="toc-text">vue的指令有哪些？讲几个你比较常用的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-v-modal-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">说说你对 v-modal 的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%BD%A0%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%EF%BC%8C%E8%AE%B2%E4%B8%80%E8%AE%B2"><span class="toc-text">vue修饰符你用过哪些，讲一讲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">单向数据绑定和双向数据绑定的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VUE%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">VUE数据双向绑定的原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8C%E8%AE%B2%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="toc-text">Vue事件绑定的原理，讲一下？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E5%8F%AF%E4%BB%A5%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E7%9F%A5%E9%81%93%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E8%99%9A%E6%8B%9Fdom%E8%BF%9B%E8%A1%8Cdiff%E6%A3%80%E6%B5%8B%EF%BC%9F"><span class="toc-text">Vue可以数据劫持知道数据变化，为什么还要虚拟dom进行diff检测？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VUE%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%94%BE%E5%93%AA%EF%BC%9F"><span class="toc-text">VUE的网络请求放哪？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VUE%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">VUE的生命周期有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E7%9A%84%E7%94%9F%E5%91%BD%E9%92%A9%E5%AD%90%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-text">Vue的生命钩子如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E5%92%8C%E6%99%AE%E9%80%9A%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">函数式组件和普通组件的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E4%B8%AD-key%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">Vue中 key的作用和原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#watch%E3%80%81methods-%E5%92%8C-computed-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">watch、methods 和 computed 的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-show%E5%92%8Cv-if%E6%8C%87%E4%BB%A4%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-text">v-show和v-if指令的共同点和不同点?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Vue%E4%B8%AD%E7%9A%84v-if-%E5%92%8Cv-for%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%B8%80%E8%B5%B7%E7%94%A8%EF%BC%9F"><span class="toc-text">为什么Vue中的v-if 和v-for不建议一起用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#delete%E5%92%8Cvue-delete%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">delete和vue.delete的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E7%9A%84%E6%9C%89%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">Vue的有用的属性和方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-vue-router"><span class="toc-text">说说 vue-router</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#route-%E5%92%8C-router-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">route 和 router 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E7%94%A8%E8%BF%87%E7%9A%84%E7%9A%84%E8%B7%AF%E7%94%B1%E5%87%BD%E6%95%B0%E9%92%A9%E5%AD%90-%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB-%EF%BC%9F"><span class="toc-text">说一下你用过的的路由函数钩子(路由导航守卫)？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%BD%BF%E7%94%A8%E8%BF%87Vue%E7%9A%84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%EF%BC%8C%E8%AE%B2%E4%B8%80%E4%B8%8B"><span class="toc-text">有使用过Vue的动态路由，讲一下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9VUEX%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">讲一下你对VUEX的理解?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%8A%8A%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E6%94%BE%E5%9C%A8vuex%E4%B8%AD%EF%BC%8C%E4%BD%A0%E6%94%BE%E5%9C%A8%E9%82%A3%E9%87%8C%EF%BC%9F"><span class="toc-text">如果把数据请求放在vuex中，你放在那里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex%E7%9A%84%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">Vuex的属性有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E8%A6%81%E4%BC%98%E5%8C%96%E4%B8%80%E4%B8%AAVue%E9%A1%B9%E7%9B%AE%EF%BC%8C%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-text">如果要优化一个Vue项目，怎么做？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8BVue%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%EF%BC%8C%E4%BD%A0%E6%80%8E%E4%B9%88%E5%86%99%E7%9A%84%EF%BC%9F"><span class="toc-text">讲一下Vue的自定义指令，你怎么写的？</span></a></li></ol></li></ol>
  </div>
</aside>

  
  
    <aside class="passage-copyright">
      <div>本文作者: 饿包子</div>
      
        <div>
          原文链接: 
          <a href="" target="_blank">https://lixianbin1.github.io/blog/2020/10/27/%E3%80%90%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6%E3%80%91%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E6%94%B6%E9%9B%86%E5%92%8C%E6%80%BB%E7%BB%93(Vue%20%E7%AF%87)/</a>
        </div>
      
      <div>
        版权声明: 本博客所有文章除特别声明外, 均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议. 转载请注明出处!
      </div>
    </aside>
  
  
</div>

    </main>

    <!-- gitalk评论系统 -->
    

    
<div class="site-footer-wrapper">
  <footer class="site-footer">
    
      
        <div class="site-footer-col">
          <h5 class="site-footer-title">网站推荐</h5>
          
            <span class="site-footer-item">
              <a href="https://tympanus.net/codrops/" target="_blank">Codrops</a>
            </span>
          
            <span class="site-footer-item">
              <a href="http://taobaofed.org/" target="_blank">淘宝前端团队(FED)</a>
            </span>
          
        </div>
      
        <div class="site-footer-col">
          <h5 class="site-footer-title">文档教程</h5>
          
            <span class="site-footer-item">
              <a href="https://es6.ruanyifeng.com/" target="_blank">ES6入门</a>
            </span>
          
            <span class="site-footer-item">
              <a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank">MDN Web文档</a>
            </span>
          
        </div>
      
        <div class="site-footer-col">
          <h5 class="site-footer-title">兴趣前沿</h5>
          
            <span class="site-footer-item">
              <a href="https://threejs.org/" target="_blank">threejs</a>
            </span>
          
            <span class="site-footer-item">
              <a href="https://github.com/justadudewhohacks/face-api.js" target="_blank">face-api</a>
            </span>
          
        </div>
      
    
    <div class="site-footer-info">
      <i class="fa fa-clock-o"></i> 本站已稳定运行<span id="site-time"></span>
    </div>
    
    
      <div class="site-footer-info">
        <i class="fa fa-at"></i> Email: xianbin.me@qq.com
      </div>
    
  </footer>
</div>
    <div id="site-layer" style="display:none;">
  <div class="site-layer-content">
    <div class="site-layer-header">
      <span class="site-layer-header-title" id="site-layer-title"></span>
      <i class="fa fa-close" id="site-layer-close"></i>
    </div>
    <div class="site-layer-body" id="site-layer-container">
      <div class="site-layer-input" id="site-layer-search" style="display: none;">
        <input type="text">
        <i class="fa fa-search"></i>
      </div>
      
      <div id="site-layer-welcome" style="display:none;"></div>
    </div>
  </div>
</div>
    

<div class="bottom-bar">
  
  
  
  <div class="bottom-bar-right">
    <a href="javascript:void(0);" data-enable="true" id="site-toc-show-btn">
      <i class="fa fa-bars"></i>
    </a>
    <a href="javascript:void(0);" id="site-toggle-share-btn">
      <i class="fa fa-share-alt"></i>
    </a>
    
    <a href="javascript:void(0);" id="back-top-btn">
      <i class="fa fa-chevron-up"></i>
    </a>
  </div>
</div>
    <div id="share-btn">
  
  
  
    <a id="share-btn-weibo" href="javascript:void(0);" target="_blank">
      <i class="fa fa-weibo"></i>
    </a>
  
  
    <a id="share-btn-qq" href="javascript:void(0);" target="_blank">
      <i class="fa fa-qq"></i>
    </a>
  
  
</div>
    





    
  </body>
</html>